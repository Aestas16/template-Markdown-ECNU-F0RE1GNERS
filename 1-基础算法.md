# 基础算法
## 哈希
### 树哈希
dmy 牛逼！参考自 [dmy 的博客](https://peehs-moorhsum.blog.uoj.ac/blog/7891)。

考虑这样一种哈希方式。对于一棵以 $u$ 为根的子树，定义子树的哈希 $\text{Hash}(u)=1+\displaystyle\sum_{(u, v)}f(\text{Hash}(v))$。其中 $f$ 为一个待定函数。

一种比较优秀的 $f$ 函数如下：
```cpp
ull h(ull x) { return x * x * x * 672328094 + 22637261; }
ull f(ull x) { return h((x << 32) >> 32) + h(x >> 32); }
```

例题：[UOJ #763 树哈希](https://uoj.ac/problem/763)。
## 二分
### 整体二分
顾名思义，把多个询问放在一起二分答案。

记 $\text{solve}(l, r, Q)$ 表示当前正在处理集合 $Q$ 中的询问，且集合 $Q$ 中的询问答案在 $[l,r]$ 内，我们对于 $Q$ 中每个询问查询 $\text{mid}=\dfrac{l+r}{2}$ 是否合法，然后就可以将 $Q$ 分为 $Q_0, Q_1$，其中 $Q_0$ 的答案值域为 $[l,\text{mid})$，$Q_1$ 的答案值域为 $[\text{mid},r]$。

时间复杂度 $\Theta(Q\cdot a \log \text{maxans}+\text{maxans}\cdot b)$，其中查询的时间为 $\Theta(a)$，修改的时间为 $\Theta(b)$。

例题：YZOJ P5680 [FOI 2022 多校联训 Round 12]帝国防卫（校内题）。
### wqs 二分
高级的东西。

如果有一个凸函数 $f(x)\ (x \in A)$，而我们能在 $\Theta(m)$ 的时间内求出它的最大值（对于上凸函数）或最小值（对于下凸函数），那么我们就能 $\Theta(m \log |A|)$ 求出 $f(x)$ 在 $p$ 处的取值。

我们发现，对于一个凸函数，它的导函数一定是单调增/减的，也就是说我们可以不断二分凸壳上的切点斜率，直到切到点 $p$ 为止。

那么我们要怎么求出某个斜率 $k$ 切到凸壳上的哪个点呢？注意到对于一个上凸壳，直线$y=kx+b$ 与其相切时，$b$ 最大，下凸壳则 $b$ 最小。然后我们有 $b=y-kx$，那么我们把与 $x$ 相关的量扣去 $k$ 的贡献，然后对其求最大值即可。下凸壳同理可得。

这就是 wqs 二分！注意编写时的细节：由于 $f(x)$ 可能包含多点共线，也就是说 $(p,f(p))$ 可能不会被切到，而是切到与其共线的点上，因此每次二分时更新答案都应按照切到点 $p$ 来更新答案。

关于 $\log |A|$：其实斜率的范围应该不完全等于值域范围？做题时得具体分析斜率范围。

例题：[洛谷 P2619 [国家集训队]Tree I](https://www.luogu.com.cn/problem/P2619)。

## 分治
### CDQ 分治
用于给问题降维。如高维点对计数、计算高维点对权值、优化多维偏序 DP 过程、动态问题转静态等。

分治过程：假设当前在处理 $[l,r]$ 内的点对，那么我们只计算跨过 $\text{mid}=\dfrac{l+r}{2}$ 的点对贡献，剩下的递归到 $[l,\text{mid}]$、$[\text{mid}+1,r]$ 内处理。下面介绍一些具体的例子：

**三维偏序**：将第一维排序后开始 CDQ 分治，我们需要计算跨过 $\text{mid}$ 的点对数量，那么我们现在将 $[l,\text{mid}],[\text{mid}+1,r]$ 内均按第一维排序，然后双指针将满足 $b_l < b_r$ 的位置 $r$ 扔进树状数组，然后用树状数组进行第三维偏序的计数即可。时间复杂度 $\Theta(n \log^2 n)$。

**优化 1D/1D 偏序 DP**：假设我们有转移方程：

$$f_i=1+\max_{j=1}^{i-1}\{f_j\mid a_j<a_i \land b_j<b_i\}$$

这显然是一个三维偏序的转移，第一维 $i$ 已默认排好序，直接 CDQ 分治：先递归处理 $[l,\text{mid}]$ 的转移，再处理跨过 $\text{mid}$ 的转移（同样使用双指针+树状数组维护前缀最大值），最后递归处理 $[\text{mid}+1,r]$ 的转移。注意这里处理过程必须按照中序遍历的顺序，原因显然。时间复杂度 $\Theta(n \log^2 n)$。

**动态问题转静态**：将所有的操作多加一维时间作为第一维，然后使用 CDQ 分治处理，此时所有的修改都在询问之前就已完成，我们只需要处理静态的问题即可。例如 矩阵加 与 矩阵求和 操作，使用 CDQ 分治后就变为静态的矩形面积并，线段树维护即可，不需要树套树。实现了问题的「降维」。

再说一个技巧：**CDQ 分治套 CDQ 分治**。

我们上述问题中计算跨过 $\text{mid}$ 的贡献时都使用了数据结构，但此时我们其实可以转换问题，再使用一个内层的 CDQ 分治解决。

以三维偏序为例，我们考虑计算跨过 $\text{mid}$ 的贡献时问题转换为了什么：
1. 将第一维在 $[l, \text{mid}]$ 中的点加入到点集中；
2. 对于每个第一维在 $[\text{mid + 1}, r]$ 中的点，计算有点集内有多少个点的第二维第三维都比它小。

然后考虑用 CDQ 分治解决这个问题，将第二维排序，问题变为顺序枚举每个点，然后做如下操作：
1. 遇到第一维在 $[l, \text{mid}]$ 中的点，将其加入到点集中；
2. 遇到第一维在 $[\text{mid + 1}, r]$ 中的点，计算有点集内有多少个点的第三维比它小。

也就是说我们需要维护一个动态的一维偏序，化用上面的**动态问题转静态**套路，我们使用 CDQ 分治处理这个问题后，只需要解决静态的一维偏序，前缀和即可。

CDQ 分治套 CDQ 分治的时间复杂度仍为 $\Theta(n \log^2 n)$。

例题：[洛谷 P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157)，[洛谷 P2487 [SDOI2011]拦截导弹](https://www.luogu.com.cn/problem/P2487)。
### 线段树分治
解决一类问题模型：
- 有一些仅对一段时间有贡献的操作；
- 计算某个点的贡献。

将时间看作一个轴，对时间轴建线段树。将贡献操作扔到线段树上，然后遍历整棵线段树，遇到带贡献的节点就加入贡献，遇到叶子节点计算贡献，退出某个节点时将贡献恢复。

时间复杂度 $\Theta(m\cdot a \log n)$，其中计算贡献和加入贡献的时间复杂度为 $\Theta(a)$。

例题：YZOJ P5394 连连通通（校内题）。

```cpp
const int N = 2e5, M = N << 2;

int n, m, k, top, fa[N + 10], sz[N + 10];

struct Edge {
    int x, y;
} e[N + 10];

struct Node {
    int x, y, val;
} stk[M + 10];

vector<int> qwq[M + 10];

int find(int x) {
    while (x != fa[x]) x = fa[x];
    return fa[x];
}

void merge(int x, int y) {
    x = find(x), y = find(y);
    if (sz[x] > sz[y]) swap(x, y);
    stk[++top] = {x, y, sz[x]}, fa[x] = y, sz[y] += sz[x];
}

void update(int u, int ql, int qr, int val, int l = 1, int r = k) {
    if (l > qr || r < ql) return;
    if (ql <= l && r <= qr) return (void)(qwq[u].push_back(val));
    int mid = (l + r) >> 1;
    update(u << 1, ql, qr, val, l, mid), update(u << 1 | 1, ql, qr, val, mid + 1, r);
}

void sgtdiv(int u, int l, int r) {
    bool ans = 1;
    int lsttop = top;
    for (int i = 0; i < qwq[u].size(); i++) {
        int x = find(e[qwq[u][i]].x), y = find(e[qwq[u][i]].y);
        if (x == y) {
            for (int k = l; k <= r; k++) puts("No");
            ans = 0;
            break;
        }
        merge(e[qwq[u][i]].x, e[qwq[u][i]].y + n), merge(e[qwq[u][i]].y, e[qwq[u][i]].x + n);
    }
    if (ans) {
        if (l == r)
            puts("Yes");
        else {
            int mid = (l + r) >> 1;
            sgtdiv(u << 1, l, mid), sgtdiv(u << 1 | 1, mid + 1, r);
        }
    }
    while (top > lsttop) sz[fa[stk[top].x]] -= stk[top].val, fa[stk[top].x] = stk[top].x, top--;
    return;
}

int main() {
    fr(n), fr(m), fr(k);
    for (int i = 1, l, r; i <= m; i++) fr(e[i].x), fr(e[i].y), fr(l), fr(r), l++, update(1, l, r, i);
    for (int i = 1; i <= n * 2; i++) fa[i] = i, sz[i] = 1;
    return sgtdiv(1, 1, k), 0;
}
```