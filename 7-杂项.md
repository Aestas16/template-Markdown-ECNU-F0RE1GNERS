# 杂项
## 随机化
### 随机调整法
dmy 牛逼！！！11111 参考自《邓明扬 一类调整算法在信息学竞赛中的应用》。

对一个初始解进行不断地调整从而获得较优解的方法。以 $100\%$ 的概率接受较优解，以一定的概率接受等优解。

很优秀。
### 模拟退火
随机调整法的进阶版本。整一个当前温度 $T$ 和降温系数 $\alpha$，不断降温至 $T < \epsilon$，每次降温都伴随着一次对解的调整更新。

以 $100\%$ 的概率接受较优解，以 $e^{-\frac{\Delta}{T}}$ 的概率接受较劣解。其中 $\Delta$ 为较劣解与当前解的差距。

注意调参。

## 0/1 分数规划
这东西也能忘的。。。。。？？？？

**问题**：最大/小化下式：

$$\displaystyle\frac{\sum\limits_{i=1}^na_i\times w_i}{\sum\limits_{i=1}^nb_i\times w_i}$$

其中 $w_i \in \{0,1\}$。

显然答案满足单调性，二分一个答案 $\text{mid}$，check 其是否可行，以最大值为例：

$$
\displaystyle
\begin{aligned}
&\frac{\sum a_i\times w_i}{\sum b_i\times w_i}>\text{mid}\\
\Longrightarrow&\sum a_i\times w_i-\text{mid}\times \sum b_i\cdot w_i>0\\
\Longrightarrow&\sum w_i\times(a_i-\text{mid}\times b_i)>0
\end{aligned}
$$

然后就是求 $\sum w_i\times(a_i-\text{mid}\times b_i)$，根据题意用你聪明的脑袋瓜子选用合适的算法解决即可。

## $\Theta(k^2 \log n)$ 常系数齐次线性递推
原理来不及复习了，直接记。

快速记忆方法：一遍加法卷积卷 $a,b$，一遍减法卷积卷结果和递推式。最后把卷完 $n$ 次的东西与初始值加权求和得到答案。

初始 $a_2=w_1=1$。

```cpp
void mul(const mint *a, const mint *b, mint *c) {
    static mint t[N + 10];
    for (int i = 1; i <= k * 2 - 1; i++) t[i] = 0;
    for (int i = 1; i <= k; i++) for (int j = 1; j <= k; j++) t[i + j - 1] += a[i] * b[j];
    for (int i = k * 2 - 1; i >= k + 1; i--) for (int j = 1; j <= k; j++) t[i - j] += t[i] * arr[j];
    for (int i = 1; i <= k; i++) c[i] = t[i];
}
mint calc(int n) {
    static mint a[N + 10], w[N + 10], ret; ret = 0, a[2] = w[1] = 1;
    for (; n; n >>= 1, mul(a, a, a)) if (n & 1) mul(a, w, w);
    for (int i = 1; i <= k; i++) ret += f[i] * w[i];
    return ret;
}
```

上述代码中 $f$ 为数列的初始项，$k$ 为递推阶数，$arr$ 为递推系数，calc(n) 求的是数列第 $n$ 项。

## BM 算法
然而只有上面那个东西是没啥用的，配合 BM 才能打出超强力的效果！！！

BM 用来求一个数列的最短递推式。构造其实很简单，分三步走：
1. 如果当前递推式已经契合，不需要更新；
2. 如果不契合且当前递推式是第一个版本，直接给第二个版本扔进去 $i$ 个 $0$；
3. 如果不契合且不是第一个版本，令 $f$ 为当前的 $\Delta$ 与上一个版本的 $\Delta$ 之商，$\text{fail}_i$ 为版本 $i$ 的失配位置。然后按如下构造当前递推式：
   - 往新版本递推式里扔 $i-\text{fail}_{c-1}-1$ 个 $0$，再把 $w$ 扔进去；
   - 把上一个版本的递推式全部乘上 $-w$ 然后扔进新版本递推式末尾；
   - 把当前版本递推式加到新版本递推式上；
   - 去除末尾的 $0$。

整完了，代码：
```cpp
#include <bits/stdc++.h>
#include <atcoder/modint>

using namespace atcoder;
using namespace std;

template <class T> void fr(T &a, bool f = 0, char ch = getchar()) {
    for (a = 0; ch < '0' || ch > '9'; ch = getchar()) (ch == '-') && (f = 1);
    for (; ch >= '0' && ch <= '9'; ch = getchar()) a = a * 10 + (ch - '0');
    f && (a = -a);
}
template <class T, class... Y> void fr(T &a, Y &...b) { fr(a), fr(b...); }
int fr() { int a; return fr(a), a; }

using mint = modint998244353;

const int N = 1e4;

int m, k, fail[N + 10];
mint f[N + 10], d[N + 10], arr[N + 10];
vector<mint> g[N + 10];

void solve() {
    int c = 0;
    for (int i = 1; i <= m; i++) {
        mint tmp = f[i];
        for (int j = 0; j < g[c].size(); j++) tmp -= g[c][j] * f[i - j - 1];
        d[i] = tmp;
        if (tmp == 0) continue;

        fail[c] = i;
        if (c == 0) { g[++c].resize(i); continue; }

        mint w = d[i] / d[fail[c - 1]];
        c++, g[c].resize(i - fail[c - 2] - 1), g[c].push_back(w);
        for (int j = 0; j < g[c - 2].size(); j++) g[c].push_back(-w * g[c - 2][j]);

        if (g[c].size() < g[c - 1].size()) g[c].resize(g[c - 1].size());
        for (int j = 0; j < g[c - 1].size(); j++) g[c][j] += g[c - 1][j];

        while (g[c].back() == 0) g[c].pop_back();
    }
    k = g[c].size();
    for (int i = 0; i < k; i++) arr[i + 1] = g[c][i], printf("%d%c", arr[i + 1].val(), " \n"[i + 1 == k]);
}
void mul(const mint *a, const mint *b, mint *c) {
    static mint t[N + 10];
    for (int i = 1; i <= k * 2 - 1; i++) t[i] = 0;
    for (int i = 1; i <= k; i++) for (int j = 1; j <= k; j++) t[i + j - 1] += a[i] * b[j];
    for (int i = k * 2 - 1; i >= k + 1; i--) for (int j = 1; j <= k; j++) t[i - j] += t[i] * arr[j];
    for (int i = 1; i <= k; i++) c[i] = t[i];
}
mint calc(int n) {
    static mint a[N + 10], w[N + 10], ret; ret = 0, a[2] = w[1] = 1;
    for (; n; n >>= 1, mul(a, a, a)) if (n & 1) mul(a, w, w);
    for (int i = 1; i <= k; i++) ret += f[i] * w[i];
    return ret;
}

struct OI {
    int RP, score;
} CSPS2022, NOIP2022;

signed main() {
    CSPS2022.RP++, CSPS2022.score++, NOIP2022.RP++, NOIP2022.score++;
    int n; fr(m, n);
    for (int i = 1; i <= m; i++) f[i] = fr();
    solve(), printf("%d\n", calc(n).val());
    return 0;
}
```