# æ•°æ®ç»“æ„
## ç¬›å¡å°”æ ‘
ä¸€ä¸ªæ»¡è¶³ã€Œä¸­åºéå†åºåˆ—æ˜¯åŸåºåˆ—ã€çš„å †ï¼Œæ”¾ä¸ªå›¾ï¼š
![](cartesian-tree1.png)

æ€ä¹ˆå»ºç¬›å¡å°”æ ‘ï¼Ÿå•è°ƒæ ˆå³å¯ï¼Œå¦‚æœå®åœ¨ä¸ä¼šä¹Ÿå¯ä»¥å†™å¤šä¸ª $\log$ çš„ ST è¡¨ã€‚æ€ä¹ˆç”¨ï¼Ÿç”±äºæ ‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹è¡¨ç¤ºäº†ä¸€ä¸ªåŒºé—´çš„æœ€å¤§/å°å€¼ï¼Œå…·æœ‰è‰¯å¥½çš„æ€§è´¨ï¼Œæ¯”å¦‚å¯ä»¥åˆ†æ²»åšä¸€äº›ä¸œè¥¿ã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P7244 ç« èŠ‚åˆ’åˆ†](https://www.luogu.com.cn/problem/P7244)ã€‚

```cpp
const int N = 392699;
 
int n, k, top, val, mx, rt, a[N + 10], stk[N + 10], ch[N + 10][2];
 
int solve(int u, int l = 1, int r = n) {
    if (u == 0) return 0;
    if (a[u] % val == 0) return solve(ch[u][0], l, u - 1) + solve(ch[u][1], u + 1, r) + 1;
    int ret = 0;
    if (l != 1) ret = max(ret, solve(ch[u][1], u + 1, r));
    if (r != n) ret = max(ret, solve(ch[u][0], l, u - 1));
    return ret;
}
 
signed main() {
    fr(n, k);
    for (int i = 1; i <= n; i++) fr(a[i]), mx = max(mx, a[i]);
    for (int i = 1; i <= n; i++) {
        while (top && a[stk[top]] <= a[i]) ch[i][0] = stk[top--];
        if (top) ch[stk[top]][1] = i;
        stk[++top] = i;
    }
    rt = stk[1];
    for (int i = mx; i; i--) {
        if (mx % i) continue;
        val = i;
        if (solve(rt) >= k) return printf("%d\n", i), 0;
    }
    return 0;
}
```
## çº¿æ®µæ ‘
### æè¶…çº¿æ®µæ ‘
è€ƒåœºä¸Šæ‰‹ç”»ä¸€ä¸‹å›¾ç„¶åç°æ¨ã€Œä¼˜åŠ¿çº¿æ®µã€çš„ç»´æŠ¤å°±è¡Œã€‚

æ„Ÿè§‰è¿™ä¸œè¥¿ä¼˜åŒ– DP æ¯”æ–œç‡ä¼˜åŒ–å¥½å†™å¤šäº†ï¼Œå°±æ˜¯æœ‰çš„æ—¶å€™æ¯”æ–œç‡ä¼˜åŒ–å¤šä¸ª $\log$ã€‚

```cpp
const int N = 39989, P1 = 39989, P2 = 1e9, INF = 0x7f7f7f7f;

int n, lstans, ltot;

struct Line {
    double k, b; int id;
    Line(double k = 0, double b = -INF, int id = 0) : k(k), b(b), id(id) {}
    double operator [] (const int &x) { return k * x + b; }
};

struct Node {
    Line cur; Node *ch[2];
} mem[(N << 1) + 10], *atot = mem, *rt;

Line max(int x, Line a, Line b) {
    if (a[x] > b[x]) return a;
    if (a[x] < b[x]) return b;
    return a.id < b.id ? a : b;
}

void modify(Node *&u, Line val, int ql, int qr, int l = 1, int r = 39989) {
    if (ql > r || qr < l) return ;
    if (u == 0) u = ++atot;
    int mid = (l + r) >> 1;
    if (ql <= l && qr >= r) {
        if (val[mid] > u->cur[mid]) swap(val, u->cur);
        if (u->cur[l] < val[l]) return modify(u->ch[0], val, ql, qr, l, mid);
        else if (u->cur[r] < val[r]) return modify(u->ch[1], val, ql, qr, mid + 1, r);
        return ;
    }
    modify(u->ch[0], val, ql, qr, l, mid), modify(u->ch[1], val, ql, qr, mid + 1, r);
}
Line qmax(Node *u, int pos, int l = 1, int r = 39989) {
    if (u == 0) return 0;
    Line ret = u->cur; int mid = (l + r) >> 1;
    return max(pos, ret, (pos <= mid) ? qmax(u->ch[0], pos, l, mid) : qmax(u->ch[1], pos, mid + 1, r));
}

void p1(int &x) { x = (x + lstans - 1) % P1 + 1; }
void p2(int &x) { x = (x + lstans - 1) % P2 + 1; }

signed main() {
    fr(n);
    for (int i = 1, opt, k, x0, y0, x1, y1, l, r; i <= n; i++) {
        fr(opt);
        if (opt == 0) fr(k), p1(k), printf("%d\n", lstans = qmax(rt, k).id);
        else {
            fr(x0), fr(y0), fr(x1), fr(y1), p1(x0), p2(y0), p1(x1), p2(y1), ltot++;
            if (x0 > x1) l = x1, r = x0;
            else l = x0, r = x1;
            if (x0 == x1) modify(rt, Line(0, max(y0, y1), ltot), l, r);
            else {
                double lk = 1.0 * (y1 - y0) / (x1 - x0);
                modify(rt, Line(lk, y0 - x0 * lk, ltot), l, r);
            }
        }
    }
    return 0;
}
```
### çº¿æ®µæ ‘åˆå¹¶
ä¸€èˆ¬ç”¨äºå¿«é€Ÿåˆå¹¶ä¸¤ä¸ªæ•°ç»„çš„ä¿¡æ¯ï¼Œå¤šç”¨äºæ ‘ä¸Š DP æ—¶åŠ é€Ÿè½¬ç§»ã€‚å¯ä»¥è¯æ˜æ—¶é—´å¤æ‚åº¦æ˜¯ $\Theta(n \log n)$ çš„ã€‚

```cpp
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    ... // å°† y çš„ä¿¡æ¯åˆå¹¶åˆ° x ä¸Š
    x->ch[0] = merge(x->ch[0], y->ch[0]), x->ch[1] = merge(x->ch[1], y->ch[1]), x->pushup();
    return x;
}
```
### å…”é˜Ÿçº¿æ®µæ ‘
useful trickã€‚ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤å‰ç¼€æœ€å¤§å€¼çš„ä¸€ä¸ª trickã€‚

æµ…ä¸¾ä¸ªä¾‹å­ï¼šæŸ¥è¯¢åŒºé—´æœ¬è´¨ä¸åŒå‰ç¼€æœ€å¤§å€¼æ•°é‡ã€‚æˆ‘ä»¬å¯¹çº¿æ®µæ ‘ä¸Šçš„ä¸€ä¸ªèŠ‚ç‚¹ $[l,r]$ ç»´æŠ¤ä¸¤ä¸ªä¿¡æ¯ï¼š
1. åŒºé—´æœ€å¤§å€¼ $\max$ã€‚
2. ä»…è€ƒè™‘åŒºé—´ $[l,r]$ æ—¶ï¼Œè¯¥åŒºé—´çš„ç­”æ¡ˆ $\text{ans}$ã€‚

ç„¶åæˆ‘ä»¬è€ƒè™‘ pushupï¼Œä¼šå‘ç° $\text{ans}$ å¥½åƒä¸å¤ªå¥½åˆå¹¶å•Šï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ç»§æ‰¿å·¦å„¿å­çš„ç­”æ¡ˆï¼Œä½†æ˜¯è¦è®¡ç®—å³å­æ ‘çš„ç­”æ¡ˆæˆ‘ä»¬è¿˜å¾—è€ƒè™‘å·¦å­æ ‘çš„æœ€å¤§å€¼ ğŸ¤”

äºæ˜¯æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå‡½æ•° $\text{calc}(i,pre)$ è¡¨ç¤ºèŠ‚ç‚¹ $i$ è€ƒè™‘äº†å‰é¢å«æœ‰æœ€å¤§å€¼ $pre$ çš„ç­”æ¡ˆï¼ˆæŠ„çš„ç²‰å…”åšå®¢ä»£ç ï¼‰ï¼š

$$
\displaystyle \begin{array}{l} \textbf{def: } \mathrm{calc}(i, pre) \\ \qquad \textbf{if } (i \text{ is a leaf node}) \\ \qquad \qquad \textbf{return } {\color{green}{[\max[i] > pre]}} \\ \qquad \textbf{else} \\ \qquad \qquad \textbf{if } (\max[\mathrm{leftchild}[i]] > pre) \\ \qquad \qquad \qquad \textbf{return } {\color{blue}{\mathrm{calc}(\mathrm{leftchild}[i], pre)}} + {\color{red}{(\mathrm{ans}[i] - \mathrm{ans}[\mathrm{leftchild}[i]])}} \\ \qquad \qquad \textbf{else} \\ \qquad \qquad \qquad \textbf{return } {\color{blue}{0}} + {\color{red}{\mathrm{calc}(\mathrm{rightchild}[i], pre)}} \\ \qquad \qquad \textbf{endif.} \\ \qquad \textbf{endif.} \\ \textbf{enddef.} \end{array}
$$

ç»¿è‰²ä¸ºå¶å­èŠ‚ç‚¹çš„è´¡çŒ®ï¼Œè“è‰²ä¸ºå·¦å­æ ‘è´¡çŒ®ï¼Œçº¢è‰²ä¸ºå³å­æ ‘è´¡çŒ®ã€‚

ç¬¬ä¸€å—çº¢è‰²é‚£é‡Œä¸å¤ªå¥½ç†è§£ï¼Œä½†æ˜¯èªæ˜çš„å¤§å®¶ä¸€å®šèƒ½æ‡‚ï¼å°±ä¸è§£é‡Šäº†ï¼

ç„¶åæˆ‘ä»¬å‘ç°ç¬¬ä¸€å—çº¢è‰²é‚£è¾¹è¦åšå‡æ³•ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬ç»´æŠ¤çš„ä¿¡æ¯è¦æ»¡è¶³å¯å‡æ€§ï¼Ÿé‚£å¥½åƒæœ‰ç‚¹æ‹‰å•Šï¼Œæˆ‘ä»¬è€ƒè™‘ä¿®æ”¹ $\text{ans}$ çš„å®šä¹‰ï¼š
- ä»…è€ƒè™‘åŒºé—´ $[l,r]$ æ—¶ï¼Œå³å„¿å­åŒºé—´çš„ç­”æ¡ˆ $\text{ans}$ã€‚
- å¶å­èŠ‚ç‚¹çš„ $\text{ans}$ æ— æ„ä¹‰ã€‚

è¿™ä¸‹ç¬¬ä¸€å—çº¢è‰²é‚£é‡Œå°±å¯ä»¥æ”¹æˆ $\text{ans}[i]$ äº†ï¼ä¸éœ€è¦å¯å‡æ€§äº†ï¼Œé‚£ä¹ˆåªå‰©ä¸‹æ–°å®šä¹‰ $\text{ans}$ çš„ pushup é—®é¢˜ï¼Œæˆ‘ä»¬æ˜¾ç„¶æœ‰ $\mathrm{cnt}[i] = \mathrm{calc}(\mathrm{rightchild}[i], \max[\mathrm{leftchild}[i]])$ã€‚

é—®é¢˜åœ†æ»¡è§£å†³ï¼æ—¶é—´å¤æ‚åº¦ $\Theta(n \log^2 n)$ã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P4198 æ¥¼æˆ¿é‡å»º](https://www.luogu.com.cn/problem/P4198)ã€‚å°±æ˜¯ä¸Šé¢è¯´çš„è¿™ä¸ªé¢˜è¾£ï¼

```cpp
#define int long long
#define now seg[cur]
#define ls cur << 1
#define rs cur << 1 | 1
#define lch seg[ls]
#define rch seg[rs]

const int N = 1e5;

int n, m, x, y;

struct Node {
    int l, r, cnt;
    double qwq;
    Node(int l = 0, int r = 0) : l(l), r(r) { cnt = 0, qwq = 0; }
} seg[(N << 2) + 10];

void build(int cur, int l, int r) {
    now = Node(l, r);
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(ls, l, mid), build(rs, mid + 1, r);
}

int count(int cur, double &x) {
    if (now.l >= now.r) return now.qwq > x;
    if (lch.qwq <= x) return count(rs, x);
    return now.cnt - lch.cnt + count(ls, x);
}

void pushup(int cur) { now.qwq = cmax(lch.qwq, rch.qwq), now.cnt = lch.cnt + count(rs, lch.qwq); }

void modify(int cur, int &q, double &k) {
    if (now.l > q || now.r < q) return;
    if (now.l >= now.r) return (void)(now.qwq = k, now.cnt = 1);
    modify(ls, q, k), modify(rs, q, k), pushup(cur);
}

signed main() {
    cin >> n >> m, build(1, 1, n);
    while (m--) {
        cin >> x >> y;
        double tmp = (double)y / x;
        modify(1, x, tmp), cout << seg[1].cnt << endl;
    }
    return 0;
}
```

### çº¿æ®µæ ‘åˆ†æ²»
è§£å†³ä¸€ç±»é—®é¢˜æ¨¡å‹ï¼š
- æœ‰ä¸€äº›ä»…å¯¹ä¸€æ®µæ—¶é—´æœ‰è´¡çŒ®çš„æ“ä½œï¼›
- è®¡ç®—æŸä¸ªç‚¹çš„è´¡çŒ®ã€‚

å°†æ—¶é—´çœ‹ä½œä¸€ä¸ªè½´ï¼Œå¯¹æ—¶é—´è½´å»ºçº¿æ®µæ ‘ã€‚å°†è´¡çŒ®æ“ä½œæ‰”åˆ°çº¿æ®µæ ‘ä¸Šï¼Œç„¶åéå†æ•´æ£µçº¿æ®µæ ‘ï¼Œé‡åˆ°å¸¦è´¡çŒ®çš„èŠ‚ç‚¹å°±åŠ å…¥è´¡çŒ®ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹è®¡ç®—è´¡çŒ®ï¼Œé€€å‡ºæŸä¸ªèŠ‚ç‚¹æ—¶å°†è´¡çŒ®æ¢å¤ã€‚

æ—¶é—´å¤æ‚åº¦ $\Theta(m\cdot a \log n)$ï¼Œå…¶ä¸­è®¡ç®—è´¡çŒ®å’ŒåŠ å…¥è´¡çŒ®çš„æ—¶é—´å¤æ‚åº¦ä¸º $\Theta(a)$ã€‚

ä¾‹é¢˜ï¼šYZOJ P5394 è¿è¿é€šé€šï¼ˆæ ¡å†…é¢˜ï¼‰ã€‚

```cpp
const int N = 2e5, M = N << 2;

int n, m, k, top, fa[N + 10], sz[N + 10];

struct Edge {
    int x, y;
} e[N + 10];

struct Node {
    int x, y, val;
} stk[M + 10];

vector<int> qwq[M + 10];

int find(int x) {
    while (x != fa[x]) x = fa[x];
    return fa[x];
}

void merge(int x, int y) {
    x = find(x), y = find(y);
    if (sz[x] > sz[y]) swap(x, y);
    stk[++top] = {x, y, sz[x]}, fa[x] = y, sz[y] += sz[x];
}

void update(int u, int ql, int qr, int val, int l = 1, int r = k) {
    if (l > qr || r < ql) return;
    if (ql <= l && r <= qr) return (void)(qwq[u].push_back(val));
    int mid = (l + r) >> 1;
    update(u << 1, ql, qr, val, l, mid), update(u << 1 | 1, ql, qr, val, mid + 1, r);
}

void sgtdiv(int u, int l, int r) {
    bool ans = 1;
    int lsttop = top;
    for (int i = 0; i < qwq[u].size(); i++) {
        int x = find(e[qwq[u][i]].x), y = find(e[qwq[u][i]].y);
        if (x == y) {
            for (int k = l; k <= r; k++) puts("No");
            ans = 0;
            break;
        }
        merge(e[qwq[u][i]].x, e[qwq[u][i]].y + n), merge(e[qwq[u][i]].y, e[qwq[u][i]].x + n);
    }
    if (ans) {
        if (l == r)
            puts("Yes");
        else {
            int mid = (l + r) >> 1;
            sgtdiv(u << 1, l, mid), sgtdiv(u << 1 | 1, mid + 1, r);
        }
    }
    while (top > lsttop) sz[fa[stk[top].x]] -= stk[top].val, fa[stk[top].x] = stk[top].x, top--;
    return;
}

int main() {
    fr(n), fr(m), fr(k);
    for (int i = 1, l, r; i <= m; i++) fr(e[i].x), fr(e[i].y), fr(l), fr(r), l++, update(1, l, r, i);
    for (int i = 1; i <= n * 2; i++) fa[i] = i, sz[i] = 1;
    return sgtdiv(1, 1, k), 0;
}
```

### å¯æŒä¹…åŒ–çº¿æ®µæ ‘
ç©ºé—´æ˜¯ $\Theta(n \log m)$ çš„ã€‚

```cpp
const int N = 2e5;

int n, m, a[N + 10], arr[N + 10];

struct Node {
    int sum;
    Node *ch[2];
    void pushup() { sum = ch[0]->sum + ch[1]->sum; }
} mem[N * 20 + 10], *atot = mem, *rt[N + 10];

void build(Node *&u, int l = 1, int r = arr[0]) {
    u = ++atot;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(u->ch[0], l, mid), build(u->ch[1], mid + 1, r);
}
void update(Node *&u, Node *v, int pos, int val, int l = 1, int r = arr[0]) {
    u = ++atot, u->ch[0] = v->ch[0], u->ch[1] = v->ch[1], u->sum = v->sum;
    if (l == r) return u->sum += val, void();
    int mid = (l + r) >> 1;
    (pos <= mid) ? update(u->ch[0], v->ch[0], pos, val, l, mid) : update(u->ch[1], v->ch[1], pos, val, mid + 1, r);
    u->pushup();
}
int qkth(Node *ql, Node *qr, int k, int l = 1, int r = arr[0]) {
    if (l == r) return arr[l];
    int mid = (l + r) >> 1, sz = qr->ch[0]->sum - ql->ch[0]->sum;
    return (k <= sz) ? qkth(ql->ch[0], qr->ch[0], k, l, mid) : qkth(ql->ch[1], qr->ch[1], k - sz, mid + 1, r);
}

signed main() {
    fr(n, m);
    for (int i = 1; i <= n; i++) fr(a[i]), arr[i] = a[i];
    sort(arr + 1, arr + 1 + n), arr[0] = unique(arr + 1, arr + 1 + n) - arr - 1, build(rt[0]);
    for (int i = 1; i <= n; i++) update(rt[i], rt[i - 1], lower_bound(arr + 1, arr + 1 + arr[0], a[i]) - arr, 1);
    for (int i = 1, l, r, k; i <= m; i++) fr(l, r, k), printf("%d\n", qkth(rt[l - 1], rt[r], k));
    return 0;
}
```

## è«é˜Ÿ
**æ³¨æ„ç§»åŠ¨æŒ‡é’ˆçš„æ—¶å€™åº”å½“å…ˆæ‰©å¤§åŒºé—´ï¼Œå†ç¼©å°åŒºé—´ã€‚**å¾ˆé‡è¦ï¼ï¼ï¼ä¸è¿™ä¹ˆå†™çš„è«é˜Ÿæ˜¯å‡çš„ï¼ï¼ï¼
```cpp
const int N = 5e5, S = 710;

int n, m, blo, Max, a[N + 10], ans[N + 10], sum[S + 10], cnt[N + 10], bid[N + 10];

struct Query {
    int l, r, a, b, id;
    bool operator<(const Query &rhs) const {
        if (bid[l] == bid[rhs.l]) return r < rhs.r;
        return bid[l] < bid[rhs.l];
    }
} Q[N + 10];

void add(int x) {
    cnt[x]++;
    if (cnt[x] == 1) sum[bid[x]]++;
}
void del(int x) {
    cnt[x]--;
    if (cnt[x] == 0) sum[bid[x]]--;
}

int query(int l, int r) {
    int ret = 0;
    if (bid[l] == bid[r]) {
        for (int i = l; i <= r; i++) ret += (cnt[i] ? 1 : 0);
        return ret;
    }
    for (int i = bid[l] + 1; i < bid[r]; i++) ret += sum[i];
    for (int i = l; bid[i] != bid[l] + 1; i++) ret += (cnt[i] ? 1 : 0);
    for (int i = r; bid[i] != bid[r] - 1; i--) ret += (cnt[i] ? 1 : 0);
    return ret;
}

int main() {
    fr(n), fr(m), blo = sqrt(n);
    for (int i = 1; i <= n; i++) bid[i] = (i - 1) / blo + 1, fr(a[i]), Max = max(Max, a[i]);
    for (int i = 1; i <= m; i++) fr(Q[i].l), fr(Q[i].r), fr(Q[i].a), fr(Q[i].b), Q[i].id = i;
    sort(Q + 1, Q + m + 1);
    for (int i = 1, l = 1, r = 0; i <= m; i++) {
        while (Q[i].l < l) add(a[--l]);
        while (Q[i].r > r) add(a[++r]);
        while (Q[i].l > l) del(a[l++]);
        while (Q[i].r < r) del(a[r--]);
        ans[Q[i].id] = query(Q[i].a, Q[i].b);
    }
    for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
    return 0;
}
```
### å¸¦ä¿®è«é˜Ÿ
ç»™æ™®é€šè«é˜ŸåŠ ä¸€ç»´æ—¶é—´ï¼Œè¿™ä¸ªä¸æ˜¯éš¾ç‚¹ã€‚éš¾ç‚¹æ˜¯é«˜ç»´è«é˜Ÿçš„å¤æ‚åº¦åˆ†æï¼š

è®¾å—é•¿ä¸º $B$ï¼Œæ¯ä¸€ç»´å€¼åŸŸå¤§å°ä¸º $n$ï¼Œè¯¢é—®æ•°ä¸º $m$ï¼Œåˆ™ $k$ ç»´è«é˜Ÿæ—¶é—´å¤æ‚åº¦ä¸º $\Theta\left(\dfrac{n^k}{B^{k-1}}+mB\right)$ï¼Œç”±åŸºæœ¬ä¸ç­‰å¼å¾—å½“ $B=\dfrac{n}{\sqrt[k]{m}}$ æ—¶æ—¶é—´å¤æ‚åº¦å–æœ€å°å€¼ $\Theta\left(n\sqrt[k]{m^{k-1}}\right)$ã€‚

```cpp
const int N = 133333, M = 1e6;

char opt[10];
int n, q, bsz, Qtot, Ctot, col[N + 10], bid[N + 10], cnt[M + 10], ans[N + 10];

struct Query {
    int l, r, id, t;
    bool operator<(const Query &rhs) const {
        if (bid[l] == bid[rhs.l]) {
            if (bid[r] == bid[rhs.r]) return t < rhs.t;
            return r < rhs.r;
        }
        return l < rhs.l;
    }
} Q[N + 10];

struct Modify {
    int pos, val;
} C[N + 10];

void add(int x) { ans[0] += (++cnt[x] == 1); }
void del(int x) { ans[0] -= (--cnt[x] == 0); }
void modify(int p, int l, int r) {
    if (C[p].pos >= l && C[p].pos <= r) ans[0] -= (--cnt[col[C[p].pos]] == 0), ans[0] += (++cnt[C[p].val] == 1);
    swap(C[p].val, col[C[p].pos]);
}

signed main() {
    fr(n, q), bsz = pow(n, (double)2 / (double)3);
    for (int i = 1; i <= n; i++) fr(col[i]), bid[i] = (i - 1) / bsz + 1;
    for (int _ = 1, l, r; _ <= q; _++) {
        scanf("%s", opt + 1), fr(l, r);
        if (opt[1] == 'Q') Qtot++, Q[Qtot] = {l, r, Qtot, Ctot};
        else C[++Ctot] = {l, r};
    }
    sort(Q + 1, Q + Qtot + 1);
    for (int i = 1, l = 1, r = 0, t = 0; i <= Qtot; i++) {
        while (Q[i].l < l) add(col[--l]);
        while (Q[i].r > r) add(col[++r]);
        while (Q[i].l > l) del(col[l++]);
        while (Q[i].r < r) del(col[r--]);
        while (t < Q[i].t) modify(++t, Q[i].l, Q[i].r);
        while (t > Q[i].t) modify(t--, Q[i].l, Q[i].r);
        ans[Q[i].id] = ans[0];
    }
    for (int i = 1; i <= Qtot; i++) printf("%d\n", ans[i]);
    return 0;
}
```

### æ‹¬å·åºæ ‘ä¸Šè«é˜Ÿ
è€ƒåœºä¸ŠæŠŠæ‹¬å·åºç”»å‡ºæ¥ç°æ¨ä¸€ä¸‹å°±ä¼šäº†å§ï¼š
- $(u,v)$ å­˜åœ¨ç¥–å…ˆåè¾ˆå…³ç³»ï¼Œé‚£ä¹ˆæŠŠä¸¤ä¸ªç‚¹çš„å·¦æ‹¬å·ä½ç½®ä½œä¸ºè¯¢é—®åŒºé—´çš„ä¸¤ç«¯ç‚¹ï¼›
- åä¹‹ï¼ŒæŠŠä¸€ä¸ªç‚¹çš„å·¦æ‹¬å·å¦ä¸€ä¸ªç‚¹çš„å³æ‹¬å·ä½ç½®ä½œä¸ºè¯¢é—®åŒºé—´çš„ä¸¤ç«¯ç‚¹ï¼Œä½†æ˜¯è¿™æ ·ä¼šæ¼æ‰ LCAï¼Œè®°å¾—æŠŠ LCA è¡¥ä¸Šã€‚

```cpp
const int N = 4e4, M = 1e5;

int n, q, bsz, ans[M + 10], bid[(N << 1) + 10], col[N + 10], arr[(N << 1) + 10], cnt[N + 10];
vector<int> e[N + 10];
bool vis[N + 10];

void adde(int x, int y) { e[x].push_back(y); }

struct Queries {
    int l, r, id, LCA;
    bool operator < (const Queries &rhs) const {
        if (bid[l] == bid[rhs.l]) return r < rhs.r;
        return bid[l] < bid[rhs.l];
    }
} Q[M + 10];

namespace TreeLink {
    int timer, sz[N + 10], fa[N + 10], dep[N + 10], ltop[N + 10], ch[N + 10], indfn[N + 10], outdfn[N + 10];
    void dfs1(int u, int p) {
        sz[u] = 1, fa[u] = p, dep[u] = dep[p] + 1, arr[++timer] = u, indfn[u] = timer;
        for (auto v : e[u]) {
            if (v == p) continue;
            dfs1(v, u), sz[u] += sz[v];
            if (sz[v] > sz[ch[u]]) ch[u] = v;
        }
        arr[++timer] = u, outdfn[u] = timer;
    }
    void dfs2(int u, int p) {
        ltop[u] = p;
        if (ch[u] == 0) return;
        dfs2(ch[u], p);
        for (auto v : e[u]) {
            if (v == fa[u] || v == ch[u]) continue;
            dfs2(v, v);
        }
    }
    int lca(int u, int v) {
        while (ltop[u] != ltop[v]) {
            if (dep[ltop[u]] < dep[ltop[v]]) swap(u, v);
            u = fa[ltop[u]];
        }
        if (dep[u] > dep[v]) swap(u, v);
        return u;
    }
} // namespace TreeLink
using namespace TreeLink;

void modify(int x, int p) {
    if (vis[p]) ans[0] -= (--cnt[x] == 0), vis[p] = 0;
    else ans[0] += (++cnt[x] == 1), vis[p] = 1;
}

signed main() {
    fr(n, q), bsz = sqrt(n);
    for (int i = 1; i <= n; i++) fr(col[i]), arr[i] = col[i];
    for (int i = 1; i <= n * 2; i++) bid[i] = (i - 1) / bsz + 1;
    for (int i = 1, u, v; i < n; i++) fr(u, v), adde(u, v), adde(v, u);
    sort(arr + 1, arr + 1 + n), arr[0] = unique(arr + 1, arr + 1 + n) - arr - 1;
    for (int i = 1; i <= n; i++) col[i] = lower_bound(arr + 1, arr + 1 + arr[0], col[i]) - arr;
    dfs1(1, 0), dfs2(1, 1);
    for (int i = 1, u, v; i <= q; i++) {
        fr(u, v);
        if (indfn[u] > indfn[v]) swap(u, v);
        int LCA = lca(u, v);
        if (LCA == u) Q[i] = {indfn[u], indfn[v], i, 0};
        else Q[i] = {outdfn[u], indfn[v], i, LCA};
    }
    sort(Q + 1, Q + 1 + q);
    for (int i = 1, l = 1, r = 0; i <= q; i++) {
        while (Q[i].l < l) l--, modify(col[arr[l]], arr[l]);
        while (Q[i].r > r) r++, modify(col[arr[r]], arr[r]);
        while (Q[i].l > l) modify(col[arr[l]], arr[l]), l++;
        while (Q[i].r < r) modify(col[arr[r]], arr[r]), r--;
        if (Q[i].LCA) modify(col[Q[i].LCA], Q[i].LCA);
        ans[Q[i].id] = ans[0];
        if (Q[i].LCA) modify(col[Q[i].LCA], Q[i].LCA);
    }
    for (int i = 1; i <= q; i++) printf("%d\n", ans[i]);
    return 0;
}
```

## å¯å¹¶å †
### éšæœºå †
å°†å † $y$ åˆå¹¶åˆ°å † $x$ ä¸Šæ—¶ï¼Œä»¥ $0.5$ çš„æ¦‚ç‡äº¤æ¢ $x$ çš„å·¦å³å„¿å­ï¼Œç„¶åå°† $x$ çš„å·¦å„¿å­ä¸ $y$ åˆå¹¶ï¼Œå¯ä»¥è¯æ˜è¿™æ ·å­åˆå¹¶å¾—åˆ°çš„å †æ ‘é«˜æ˜¯ $\log n$ çº§åˆ«çš„ã€‚

è®°å¾—æ‰¾å †é¡¶è¦å¦å¤–è®°ä¸€ä¸ªçˆ¶äº²ç„¶åç”¨å¹¶æŸ¥é›†ç»´æŠ¤ã€‚

```cpp
const int N = 1e5;

mt19937 rnd((unsigned long long)(new char));
int n, m, fa[N + 10], ch[N + 10][2];
bool vis[N + 10];
pair<int, int> val[N + 10];

int find(int u) {
    if (fa[u] == u) return u;
    return fa[u] = find(fa[u]);
}
int merge(int x, int y) {
    if (x == 0 || y == 0) return x | y;
    if (val[x] > val[y]) swap(x, y);
    if (rnd() & 1) swap(ch[x][0], ch[x][1]);
    return ch[x][0] = merge(ch[x][0], y), x;
}

struct OI {
    int RP, score;
} FJOI2022;

signed main() {
    FJOI2022.RP++, FJOI2022.score++;
    fr(n, m);
    for (int i = 1; i <= n; i++) fr(val[i].first), val[i].second = i, fa[i] = i;
    for (int i = 1, op, x, y; i <= m; i++) {
        fr(op, x);
        if (op == 1) {
            fr(y);
            if (vis[x] || vis[y]) continue;
            x = find(x), y = find(y);
            if (x != y) fa[x] = fa[y] = merge(x, y);
        } else {
            if (vis[x]) { puts("-1"); continue; }
            x = find(x), fa[ch[x][0]] = fa[ch[x][1]] = fa[x] = merge(ch[x][0], ch[x][1]), vis[x] = 1, ch[x][0] = ch[x][1] = 0, printf("%d\n", val[x].first);
        }
    }
    return 0;
}
```

ç„¶åè¿™ä¸œè¥¿æœ‰ç‚¹ç±»ä¼¼äºçº¿æ®µæ ‘åˆå¹¶ï¼Œå¯ä»¥åœ¨å †é¡¶ä¸Šæ‰“æ ‡è®°å¯¹æ•´ä¸ªå †æ“ä½œã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P3261 [JLOI2015]åŸæ± æ”»å ](https://www.luogu.com.cn/problem/P3261)ã€‚

## å¹³è¡¡æ ‘
## FHQ Treap
ç»´æŠ¤åºåˆ—çš„æ—¶å€™æŒ‰å¤§å°æŠŠæ ‘åˆ†è£‚å¼€æå‡ºåŒºé—´æ‰“æ ‡è®°ï¼Œç»´æŠ¤é›†åˆçš„æ—¶å€™è¿˜éœ€è¦æŒ‰æƒå€¼åˆ†è£‚çš„æ“ä½œã€‚

åˆ†è£‚çš„æ—¶å€™å…ˆè€ƒè™‘å·¦å­æ ‘æ˜¯å¦å®Œå…¨è¢«åŒ…æ‹¬ï¼Œæ˜¯çš„è¯åˆ™å°†å·¦å­æ ‘åŠ å…¥å‰åŠè¾¹æ ‘é‡Œï¼Œå¾€å³å­æ ‘é€’å½’åˆ†è£‚ï¼›å¦‚æœæœªè¢«å®Œå…¨åŒ…æ‹¬ï¼Œå°†å·¦å­æ ‘åŠ å…¥ååŠè¾¹æ ‘é‡Œï¼Œå¾€å·¦å­æ ‘åˆ†è£‚é€’å½’ã€‚
```cpp
void splitsz(Node *u, int sz, Node *&x, Node *&y) {
    if (u == null) return x = y = null, void();
    u->pushdown();
    if (u->ch[0]->sz + 1 <= sz) x = u, splitsz(u->ch[1], sz - u->ch[0]->sz - 1, u->ch[1], y);
    else y = u, splitsz(u->ch[0], sz, x, u->ch[0]);
    u->pushup();
}
```

ï¼ˆä¸è¦å¿˜è®° pushdown/upï¼‰

åˆå¹¶å°±ç®€å•ä¸å°‘ï¼æˆ‘ä»¬å¾…åˆå¹¶çš„ä¸¤æ£µæ ‘å€¼åŸŸæ˜¯ä¸äº¤çš„ï¼Œä»¥ä¸‹å‡å®š $x$ æ ‘å†…çš„å€¼å‡å°äº $y$ æ ‘å†…çš„ï¼Œé‚£ä¹ˆä¸€å®šåªæœ‰ä¸¤ç§æƒ…å†µï¼š
1. å°† $x$ åˆå¹¶åˆ° $y$ çš„å·¦å­æ ‘ï¼›
2. å°† $y$ åˆå¹¶åˆ° $x$ çš„å³å­æ ‘ã€‚

é‚£ä¹ˆåˆ°åº•é€‰ç”¨é‚£ç§æƒ…å†µå‘¢ï¼Ÿæˆ‘ä»¬è€ƒè™‘ Treap è¿˜æœ‰ä¸€ä¸ªéšæœºæƒå€¼æ»¡è¶³ heap çš„æ€§è´¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ˆä»¥å°æ ¹å †ä¸ºä¾‹ï¼‰ï¼š
1. å¦‚æœç‚¹ $x$ çš„éšæœºæƒå€¼æ¯” $y$ çš„éšæœºæƒå€¼å°ï¼Œé‚£ä¹ˆå°† $y$ åˆå¹¶åˆ° $x$ çš„å³å­æ ‘ï¼›
2. å¦åˆ™ï¼Œå°† $x$ åˆå¹¶åˆ° $y$ çš„å·¦å­æ ‘ã€‚

```cpp
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    if (x->rndval < y->rndval) return x->ch[1] = merge(x->ch[1], y), x->pushup(), x;
    return y->ch[0] = merge(x, y->ch[0]), y->pushup(), y;
}
```

ç®€å•çš„ç»´æŠ¤åºåˆ—ä¾‹é¢˜ï¼š[æ´›è°· P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1](https://www.luogu.com.cn/problem/P3372)ã€‚

ä»£ç ï¼š
```cpp
#define int long long

const int N = 1e5;

int n, m;

mt19937 rnd((unsigned long long)(new char));

struct Node {
    int val, rndval, sum, atag, sz;
    Node *ch[2];
    void add(int x) { val += x, sum += sz * x, atag += x; }
    void pushup() { sum = ch[0]->sum + ch[1]->sum + val, sz = ch[0]->sz + ch[1]->sz + 1; }
    void pushdown() { if (atag) ch[0]->add(atag), ch[1]->add(atag), atag = 0; }
} mem[N + 10], *atot = mem, *rt, *null;

void Init() { null = atot, null->ch[0] = null->ch[1] = null, rt = null; }
Node *newNode(int val) { return atot++, atot->ch[0] = atot->ch[1] = null, atot->sum = atot->val = val, atot->sz = 1, atot->rndval = rnd(), atot; }

void splitsz(Node *u, int sz, Node *&x, Node *&y) {
    if (u == null) return x = y = null, void();
    u->pushdown();
    if (u->ch[0]->sz + 1 <= sz) x = u, splitsz(u->ch[1], sz - u->ch[0]->sz - 1, u->ch[1], y);
    else y = u, splitsz(u->ch[0], sz, x, u->ch[0]);
    u->pushup();
}
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    if (x->rndval < y->rndval) return x->ch[1] = merge(x->ch[1], y), x->pushup(), x;
    return y->ch[0] = merge(x, y->ch[0]), y->pushup(), y;
}

signed main() {
    Init(), fr(n, m);
    for (int i = 1; i <= n; i++) rt = merge(rt, newNode(fr()));
    for (int _ = 1, op, l, r, v; _ <= m; _++) {
        fr(op, l, r);
        Node *x, *y, *z;
        splitsz(rt, l - 1, x, y), splitsz(y, r - l + 1, y, z);
        if (op == 1) fr(v), y->add(v);
        else printf("%lld\n", y->sum);
        rt = merge(x, merge(y, z));
    }
    return 0;
}
```

## æ•°æ®ç»“æ„ä¼˜åŒ–å»ºå›¾
### å‰ç¼€å’Œä¼˜åŒ–å»ºå›¾
æ„Ÿè§‰æ²¡å•¥éœ€è¦ç‰¹åˆ«è¯´çš„ï¼Œå°±æ˜¯åˆ©ç”¨å‰ç¼€å’Œçš„æ€§è´¨ï¼ŒæŠŠå‰ç¼€ç¼©æˆä¸€ä¸ªç‚¹ç„¶åå»ºå›¾ï¼Œæ„Ÿæ€§ç†è§£ä¸€ä¸‹åœºä¸Šç°æ¨å°±æ˜¯äº†ã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P6378 [PA2010] Riddle](https://www.luogu.com.cn/problem/P6378)ã€‚
### çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾
useful trickã€‚ç”¨äºä¸€äº›éœ€è¦ç‚¹å‘åŒºé—´è¿è¾¹ / åŒºé—´å‘åŒºé—´è¿è¾¹çš„é¢˜ç›®ã€‚

æ€ä¹ˆåšï¼Ÿå»ºä¸¤æ£µçº¿æ®µæ ‘ï¼Œä¸€æ£µæ ‘ä¸Šçˆ¶äº²å‘å„¿å­è¿è¾¹æƒä¸º $0$ çš„æœ‰å‘è¾¹ï¼ˆè®°ä¸º $T_1$ï¼‰ï¼Œä¸€æ£µæ ‘ä¸Šå„¿å­å‘çˆ¶äº²è¿è¾¹æƒä¸º $0$ çš„æœ‰å‘è¾¹ï¼ˆè®°ä¸º $T_2$ï¼‰ï¼Œä¸¤æ£µæ ‘ç›¸åŒä½ç½®çš„å¶å­èŠ‚ç‚¹ä¹‹é—´è¿è¾¹æƒä¸º $0$ çš„æ— å‘è¾¹ã€‚

- ç‚¹å‘ç‚¹è¿è¾¹ï¼š$T_1,T_2$ å¯¹åº”å¶å­èŠ‚ç‚¹ç›¸è¿ã€‚
- ç‚¹å‘åŒºé—´è¿è¾¹ï¼š$T_2$ çš„å¶å­å‘ $T_1$ çš„åŒºé—´è¿è¾¹ã€‚
- åŒºé—´å‘ç‚¹è¿è¾¹ï¼š$T_2$ çš„åŒºé—´å‘ $T_1$ çš„å¶å­è¿è¾¹ã€‚
- åŒºé—´å‘åŒºé—´è¿è¾¹ï¼šå»ºä¸€ä¸ªè™šç‚¹ï¼Œ$T_1,T_2$ çš„åŒºé—´å‘è™šç‚¹è¿è¾¹ã€‚

æ„Ÿè§‰è€ƒåœºä¸Šæ‰‹ç”»ä¸¤æ£µçº¿æ®µæ ‘å°±èƒ½ç°æ¨äº†å•Š ğŸ¤”

ä¾‹é¢˜ï¼š[CF786B Legacy](https://www.luogu.com.cn/problem/CF786B)ã€‚

## æ‰‹å†™ Bitset
```cpp
struct Bitset {
    unsigned long long A[782];
    Bitset operator|(Bitset b) const {
        Bitset c;
        for (int i = 0; i <= len; i++) c.A[i] = A[i] | b.A[i];
        return c;
    }
    Bitset operator^(Bitset b) const {
        Bitset c;
        for (int i = 0; i <= len; i++) c.A[i] = A[i] ^ b.A[i];
        return c;
    }
    void reset() {
        for (int i = 0; i <= len; i++) A[i] = 0;
    }
    void set(int x) { A[x >> 6] |= 1ull << (x & 63); }
    void flip(int x) { A[x >> 6] ^= 1ull << (x & 63); }
    int count() {
        int ret = 0;
        for (int i = 0; i <= len; i++) ret += dt[A[i] >> 48] + dt[(A[i] >> 32) & S] + dt[(A[i] >> 16) & S] + dt[A[i] & S];
        return ret;
    }
}
```