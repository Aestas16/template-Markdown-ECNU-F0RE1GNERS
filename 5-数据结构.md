# æ•°æ®ç»“æ„
## ç¬›å¡å°”æ ‘
ä¸€ä¸ªæ»¡è¶³ã€Œä¸­åºéå†åºåˆ—æ˜¯åŸåºåˆ—ã€çš„å †ï¼Œæ”¾ä¸ªå›¾ï¼š
![](https://oiwiki.org/ds/images/cartesian-tree1.png)

æ€ä¹ˆå»ºç¬›å¡å°”æ ‘ï¼Ÿå•è°ƒæ ˆå³å¯ï¼Œå¦‚æœå®åœ¨ä¸ä¼šä¹Ÿå¯ä»¥å†™å¤šä¸ª $\log$ çš„ ST è¡¨ã€‚æ€ä¹ˆç”¨ï¼Ÿç”±äºæ ‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹è¡¨ç¤ºäº†ä¸€ä¸ªåŒºé—´çš„æœ€å¤§/å°å€¼ï¼Œå…·æœ‰è‰¯å¥½çš„æ€§è´¨ï¼Œæ¯”å¦‚å¯ä»¥åˆ†æ²»åšä¸€äº›ä¸œè¥¿ã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P7244 ç« èŠ‚åˆ’åˆ†](https://www.luogu.com.cn/problem/P7244)ã€‚

```cpp
const int N = 392699;
 
int n, k, top, val, mx, rt, a[N + 10], stk[N + 10], ch[N + 10][2];
 
int solve(int u, int l = 1, int r = n) {
    if (u == 0) return 0;
    if (a[u] % val == 0) return solve(ch[u][0], l, u - 1) + solve(ch[u][1], u + 1, r) + 1;
    int ret = 0;
    if (l != 1) ret = max(ret, solve(ch[u][1], u + 1, r));
    if (r != n) ret = max(ret, solve(ch[u][0], l, u - 1));
    return ret;
}
 
signed main() {
    fr(n, k);
    for (int i = 1; i <= n; i++) fr(a[i]), mx = max(mx, a[i]);
    for (int i = 1; i <= n; i++) {
        while (top && a[stk[top]] <= a[i]) ch[i][0] = stk[top--];
        if (top) ch[stk[top]][1] = i;
        stk[++top] = i;
    }
    rt = stk[1];
    for (int i = mx; i; i--) {
        if (mx % i) continue;
        val = i;
        if (solve(rt) >= k) return printf("%d\n", i), 0;
    }
    return 0;
}
```
## çº¿æ®µæ ‘
### æè¶…çº¿æ®µæ ‘
è€ƒåœºä¸Šæ‰‹ç”»ä¸€ä¸‹å›¾ç„¶åç°æ¨ã€Œä¼˜åŠ¿çº¿æ®µã€çš„ç»´æŠ¤å°±è¡Œã€‚

æ„Ÿè§‰è¿™ä¸œè¥¿ä¼˜åŒ– DP æ¯”æ–œç‡ä¼˜åŒ–å¥½å†™å¤šäº†ï¼Œå°±æ˜¯æœ‰çš„æ—¶å€™æ¯”æ–œç‡ä¼˜åŒ–å¤šä¸ª $\log$ã€‚

```cpp
const int N = 39989, P1 = 39989, P2 = 1e9, INF = 0x7f7f7f7f;

int n, lstans, ltot;

struct Line {
    double k, b; int id;
    Line(double k = 0, double b = -INF, int id = 0) : k(k), b(b), id(id) {}
    double operator [] (const int &x) { return k * x + b; }
};

struct Node {
    Line cur; Node *ch[2];
} mem[(N << 1) + 10], *atot = mem, *rt;

Line max(int x, Line a, Line b) {
    if (a[x] > b[x]) return a;
    if (a[x] < b[x]) return b;
    return a.id < b.id ? a : b;
}

void modify(Node *&u, Line val, int ql, int qr, int l = 1, int r = 39989) {
    if (ql > r || qr < l) return ;
    if (u == 0) u = ++atot;
    int mid = (l + r) >> 1;
    if (ql <= l && qr >= r) {
        if (val[mid] > u->cur[mid]) swap(val, u->cur);
        if (u->cur[l] < val[l]) return modify(u->ch[0], val, ql, qr, l, mid);
        else if (u->cur[r] < val[r]) return modify(u->ch[1], val, ql, qr, mid + 1, r);
        return ;
    }
    modify(u->ch[0], val, ql, qr, l, mid), modify(u->ch[1], val, ql, qr, mid + 1, r);
}
Line qmax(Node *u, int pos, int l = 1, int r = 39989) {
    if (u == 0) return 0;
    Line ret = u->cur; int mid = (l + r) >> 1;
    return max(pos, ret, (pos <= mid) ? qmax(u->ch[0], pos, l, mid) : qmax(u->ch[1], pos, mid + 1, r));
}

void p1(int &x) { x = (x + lstans - 1) % P1 + 1; }
void p2(int &x) { x = (x + lstans - 1) % P2 + 1; }

signed main() {
    fr(n);
    for (int i = 1, opt, k, x0, y0, x1, y1, l, r; i <= n; i++) {
        fr(opt);
        if (opt == 0) fr(k), p1(k), printf("%d\n", lstans = qmax(rt, k).id);
        else {
            fr(x0), fr(y0), fr(x1), fr(y1), p1(x0), p2(y0), p1(x1), p2(y1), ltot++;
            if (x0 > x1) l = x1, r = x0;
            else l = x0, r = x1;
            if (x0 == x1) modify(rt, Line(0, max(y0, y1), ltot), l, r);
            else {
                double lk = 1.0 * (y1 - y0) / (x1 - x0);
                modify(rt, Line(lk, y0 - x0 * lk, ltot), l, r);
            }
        }
    }
    return 0;
}
```
### çº¿æ®µæ ‘åˆå¹¶
ä¸€èˆ¬ç”¨äºå¿«é€Ÿåˆå¹¶ä¸¤ä¸ªæ•°ç»„çš„ä¿¡æ¯ï¼Œå¤šç”¨äºæ ‘ä¸Š DP æ—¶åŠ é€Ÿè½¬ç§»ã€‚å¯ä»¥è¯æ˜æ—¶é—´å¤æ‚åº¦æ˜¯ $\Theta(n \log n)$ çš„ã€‚

```cpp
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    ... // å°† y çš„ä¿¡æ¯åˆå¹¶åˆ° x ä¸Š
    x->ch[0] = merge(x->ch[0], y->ch[0]), x->ch[1] = merge(x->ch[1], y->ch[1]), x->pushup();
    return x;
}
```
### å…”é˜Ÿçº¿æ®µæ ‘
[åå­—æ¥æº](https://www.luogu.com.cn/blog/PinkRabbit/Segment-Tree-and-Prefix-Maximums)ã€‚

useful trickã€‚ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤å‰ç¼€æœ€å¤§å€¼çš„ä¸€ä¸ª trickã€‚

æµ…ä¸¾ä¸ªä¾‹å­ï¼šæŸ¥è¯¢åŒºé—´æœ¬è´¨ä¸åŒå‰ç¼€æœ€å¤§å€¼æ•°é‡ã€‚æˆ‘ä»¬å¯¹çº¿æ®µæ ‘ä¸Šçš„ä¸€ä¸ªèŠ‚ç‚¹ $[l,r]$ ç»´æŠ¤ä¸¤ä¸ªä¿¡æ¯ï¼š
1. åŒºé—´æœ€å¤§å€¼ $\max$ã€‚
2. ä»…è€ƒè™‘åŒºé—´ $[l,r]$ æ—¶ï¼Œè¯¥åŒºé—´çš„ç­”æ¡ˆ $\text{ans}$ã€‚

ç„¶åæˆ‘ä»¬è€ƒè™‘ pushupï¼Œä¼šå‘ç° $\text{ans}$ å¥½åƒä¸å¤ªå¥½åˆå¹¶å•Šï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ç»§æ‰¿å·¦å„¿å­çš„ç­”æ¡ˆï¼Œä½†æ˜¯è¦è®¡ç®—å³å­æ ‘çš„ç­”æ¡ˆæˆ‘ä»¬è¿˜å¾—è€ƒè™‘å·¦å­æ ‘çš„æœ€å¤§å€¼ ğŸ¤”

äºæ˜¯æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå‡½æ•° $\text{calc}(i,pre)$ è¡¨ç¤ºèŠ‚ç‚¹ $i$ è€ƒè™‘äº†å‰é¢å«æœ‰æœ€å¤§å€¼ $pre$ çš„ç­”æ¡ˆï¼ˆæŠ„çš„ç²‰å…”åšå®¢ä»£ç ï¼‰ï¼š

$\displaystyle \begin{array}{l} \textbf{def: } \mathrm{calc}(i, pre) \\ \qquad \textbf{if } (i \text{ is a leaf node}) \\ \qquad \qquad \textbf{return } {\color{green}{[\max[i] > pre]}} \\ \qquad \textbf{else} \\ \qquad \qquad \textbf{if } (\max[\mathrm{leftchild}[i]] > pre) \\ \qquad \qquad \qquad \textbf{return } {\color{blue}{\mathrm{calc}(\mathrm{leftchild}[i], pre)}} + {\color{red}{(\mathrm{ans}[i] - \mathrm{ans}[\mathrm{leftchild}[i]])}} \\ \qquad \qquad \textbf{else} \\ \qquad \qquad \qquad \textbf{return } {\color{blue}{0}} + {\color{red}{\mathrm{calc}(\mathrm{rightchild}[i], pre)}} \\ \qquad \qquad \textbf{endif.} \\ \qquad \textbf{endif.} \\ \textbf{enddef.} \end{array}$

ç»¿è‰²ä¸ºå¶å­èŠ‚ç‚¹çš„è´¡çŒ®ï¼Œè“è‰²ä¸ºå·¦å­æ ‘è´¡çŒ®ï¼Œçº¢è‰²ä¸ºå³å­æ ‘è´¡çŒ®ã€‚

ç¬¬ä¸€å—çº¢è‰²é‚£é‡Œä¸å¤ªå¥½ç†è§£ï¼Œä½†æ˜¯èªæ˜çš„å¤§å®¶ä¸€å®šèƒ½æ‡‚ï¼å°±ä¸è§£é‡Šäº†ï¼

ç„¶åæˆ‘ä»¬å‘ç°ç¬¬ä¸€å—çº¢è‰²é‚£è¾¹è¦åšå‡æ³•ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬ç»´æŠ¤çš„ä¿¡æ¯è¦æ»¡è¶³å¯å‡æ€§ï¼Ÿé‚£å¥½åƒæœ‰ç‚¹æ‹‰å•Šï¼Œæˆ‘ä»¬è€ƒè™‘ä¿®æ”¹ $\text{ans}$ çš„å®šä¹‰ï¼š
- ä»…è€ƒè™‘åŒºé—´ $[l,r]$ æ—¶ï¼Œå³å„¿å­åŒºé—´çš„ç­”æ¡ˆ $\text{ans}$ã€‚
- å¶å­èŠ‚ç‚¹çš„ $\text{ans}$ æ— æ„ä¹‰ã€‚

è¿™ä¸‹ç¬¬ä¸€å—çº¢è‰²é‚£é‡Œå°±å¯ä»¥æ”¹æˆ $\text{ans}[i]$ äº†ï¼ä¸éœ€è¦å¯å‡æ€§äº†ï¼Œé‚£ä¹ˆåªå‰©ä¸‹æ–°å®šä¹‰ $\text{ans}$ çš„ pushup é—®é¢˜ï¼Œæˆ‘ä»¬æ˜¾ç„¶æœ‰ $\mathrm{cnt}[i] = \mathrm{calc}(\mathrm{rightchild}[i], \max[\mathrm{leftchild}[i]])$ã€‚

é—®é¢˜åœ†æ»¡è§£å†³ï¼æ—¶é—´å¤æ‚åº¦ $\Theta(n \log^2 n)$ã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P4198 æ¥¼æˆ¿é‡å»º](https://www.luogu.com.cn/problem/P4198)ã€‚å°±æ˜¯ä¸Šé¢è¯´çš„è¿™ä¸ªé¢˜è¾£ï¼

### å¯æŒä¹…åŒ–çº¿æ®µæ ‘
ç©ºé—´æ˜¯ $\Theta(n \log m)$ çš„ã€‚

```cpp
const int N = 2e5;

int n, m, a[N + 10], arr[N + 10];

struct Node {
    int sum;
    Node *ch[2];
    void pushup() { sum = ch[0]->sum + ch[1]->sum; }
} mem[N * 20 + 10], *atot = mem, *rt[N + 10];

void build(Node *&u, int l = 1, int r = arr[0]) {
    u = ++atot;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(u->ch[0], l, mid), build(u->ch[1], mid + 1, r);
}
void update(Node *&u, Node *v, int pos, int val, int l = 1, int r = arr[0]) {
    u = ++atot, u->ch[0] = v->ch[0], u->ch[1] = v->ch[1], u->sum = v->sum;
    if (l == r) return u->sum += val, void();
    int mid = (l + r) >> 1;
    (pos <= mid) ? update(u->ch[0], v->ch[0], pos, val, l, mid) : update(u->ch[1], v->ch[1], pos, val, mid + 1, r);
    u->pushup();
}
int qkth(Node *ql, Node *qr, int k, int l = 1, int r = arr[0]) {
    if (l == r) return arr[l];
    int mid = (l + r) >> 1, sz = qr->ch[0]->sum - ql->ch[0]->sum;
    return (k <= sz) ? qkth(ql->ch[0], qr->ch[0], k, l, mid) : qkth(ql->ch[1], qr->ch[1], k - sz, mid + 1, r);
}

signed main() {
    fr(n, m);
    for (int i = 1; i <= n; i++) fr(a[i]), arr[i] = a[i];
    sort(arr + 1, arr + 1 + n), arr[0] = unique(arr + 1, arr + 1 + n) - arr - 1, build(rt[0]);
    for (int i = 1; i <= n; i++) update(rt[i], rt[i - 1], lower_bound(arr + 1, arr + 1 + arr[0], a[i]) - arr, 1);
    for (int i = 1, l, r, k; i <= m; i++) fr(l, r, k), printf("%d\n", qkth(rt[l - 1], rt[r], k));
    return 0;
}
```

## è«é˜Ÿ
**æ³¨æ„ç§»åŠ¨æŒ‡é’ˆçš„æ—¶å€™åº”å½“å…ˆæ‰©å¤§åŒºé—´ï¼Œå†ç¼©å°åŒºé—´ã€‚**å¾ˆé‡è¦ï¼ï¼ï¼ä¸è¿™ä¹ˆå†™çš„è«é˜Ÿæ˜¯å‡çš„ï¼ï¼ï¼
### å¸¦ä¿®è«é˜Ÿ
ç»™æ™®é€šè«é˜ŸåŠ ä¸€ç»´æ—¶é—´ï¼Œè¿™ä¸ªä¸æ˜¯éš¾ç‚¹ã€‚éš¾ç‚¹æ˜¯é«˜ç»´è«é˜Ÿçš„å¤æ‚åº¦åˆ†æï¼š

è®¾å—é•¿ä¸º $B$ï¼Œæ¯ä¸€ç»´å€¼åŸŸå¤§å°ä¸º $n$ï¼Œè¯¢é—®æ•°ä¸º $m$ï¼Œåˆ™ $k$ ç»´è«é˜Ÿæ—¶é—´å¤æ‚åº¦ä¸º $\Theta\left(\dfrac{n^k}{B^{k-1}}+mB\right)$ï¼Œç”±åŸºæœ¬ä¸ç­‰å¼å¾—å½“ $B=\dfrac{n}{\sqrt[k]{m}}$ æ—¶æ—¶é—´å¤æ‚åº¦å–æœ€å°å€¼ $\Theta\left(n\sqrt[k]{m^{k-1}}\right)$ã€‚
### æ‹¬å·åºæ ‘ä¸Šè«é˜Ÿ
è€ƒåœºä¸ŠæŠŠæ‹¬å·åºç”»å‡ºæ¥ç°æ¨ä¸€ä¸‹å°±ä¼šäº†å§ï¼š
- $(u,v)$ å­˜åœ¨ç¥–å…ˆåè¾ˆå…³ç³»ï¼Œé‚£ä¹ˆæŠŠä¸¤ä¸ªç‚¹çš„å·¦æ‹¬å·ä½ç½®ä½œä¸ºè¯¢é—®åŒºé—´çš„ä¸¤ç«¯ç‚¹ï¼›
- åä¹‹ï¼ŒæŠŠä¸€ä¸ªç‚¹çš„å·¦æ‹¬å·å¦ä¸€ä¸ªç‚¹çš„å³æ‹¬å·ä½ç½®ä½œä¸ºè¯¢é—®åŒºé—´çš„ä¸¤ç«¯ç‚¹ï¼Œä½†æ˜¯è¿™æ ·ä¼šæ¼æ‰ LCAï¼Œè®°å¾—æŠŠ LCA è¡¥ä¸Šã€‚

æ•´å®Œäº†ã€‚

## å¯å¹¶å †
### éšæœºå †
å°†å † $y$ åˆå¹¶åˆ°å † $x$ ä¸Šæ—¶ï¼Œä»¥ $0.5$ çš„æ¦‚ç‡äº¤æ¢ $x$ çš„å·¦å³å„¿å­ï¼Œç„¶åå°† $x$ çš„å·¦å„¿å­ä¸ $y$ åˆå¹¶ï¼Œå¯ä»¥è¯æ˜è¿™æ ·å­åˆå¹¶å¾—åˆ°çš„å †æ ‘é«˜æ˜¯ $\log n$ çº§åˆ«çš„ã€‚

è®°å¾—æ‰¾å †é¡¶è¦å¦å¤–è®°ä¸€ä¸ªçˆ¶äº²ç„¶åç”¨å¹¶æŸ¥é›†ç»´æŠ¤ã€‚

ä»£ç ï¼š
```cpp
const int N = 1e5;

mt19937 rnd((unsigned long long)(new char));
int n, m, fa[N + 10], ch[N + 10][2];
bool vis[N + 10];
pair<int, int> val[N + 10];

int find(int u) {
    if (fa[u] == u) return u;
    return fa[u] = find(fa[u]);
}
int merge(int x, int y) {
    if (x == 0 || y == 0) return x | y;
    if (val[x] > val[y]) swap(x, y);
    if (rnd() & 1) swap(ch[x][0], ch[x][1]);
    return ch[x][0] = merge(ch[x][0], y), x;
}

struct OI {
    int RP, score;
} FJOI2022;

signed main() {
    FJOI2022.RP++, FJOI2022.score++;
    fr(n, m);
    for (int i = 1; i <= n; i++) fr(val[i].first), val[i].second = i, fa[i] = i;
    for (int i = 1, op, x, y; i <= m; i++) {
        fr(op, x);
        if (op == 1) {
            fr(y);
            if (vis[x] || vis[y]) continue;
            x = find(x), y = find(y);
            if (x != y) fa[x] = fa[y] = merge(x, y);
        } else {
            if (vis[x]) { puts("-1"); continue; }
            x = find(x), fa[ch[x][0]] = fa[ch[x][1]] = fa[x] = merge(ch[x][0], ch[x][1]), vis[x] = 1, ch[x][0] = ch[x][1] = 0, printf("%d\n", val[x].first);
        }
    }
    return 0;
}
```

ç„¶åè¿™ä¸œè¥¿æœ‰ç‚¹ç±»ä¼¼äºçº¿æ®µæ ‘åˆå¹¶ï¼Œå¯ä»¥åœ¨å †é¡¶ä¸Šæ‰“æ ‡è®°å¯¹æ•´ä¸ªå †æ“ä½œã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P3261 [JLOI2015]åŸæ± æ”»å ](https://www.luogu.com.cn/problem/P3261)ã€‚

## å¹³è¡¡æ ‘
## FHQ Treap
ç»´æŠ¤åºåˆ—çš„æ—¶å€™æŒ‰å¤§å°æŠŠæ ‘åˆ†è£‚å¼€æå‡ºåŒºé—´æ‰“æ ‡è®°ï¼Œç»´æŠ¤é›†åˆçš„æ—¶å€™è¿˜éœ€è¦æŒ‰æƒå€¼åˆ†è£‚çš„æ“ä½œã€‚

åˆ†è£‚çš„æ—¶å€™å…ˆè€ƒè™‘å·¦å­æ ‘æ˜¯å¦å®Œå…¨è¢«åŒ…æ‹¬ï¼Œæ˜¯çš„è¯åˆ™å°†å·¦å­æ ‘åŠ å…¥å‰åŠè¾¹æ ‘é‡Œï¼Œå¾€å³å­æ ‘é€’å½’åˆ†è£‚ï¼›å¦‚æœæœªè¢«å®Œå…¨åŒ…æ‹¬ï¼Œå°†å·¦å­æ ‘åŠ å…¥ååŠè¾¹æ ‘é‡Œï¼Œå¾€å·¦å­æ ‘åˆ†è£‚é€’å½’ã€‚
```cpp
void splitsz(Node *u, int sz, Node *&x, Node *&y) {
    if (u == null) return x = y = null, void();
    u->pushdown();
    if (u->ch[0]->sz + 1 <= sz) x = u, splitsz(u->ch[1], sz - u->ch[0]->sz - 1, u->ch[1], y);
    else y = u, splitsz(u->ch[0], sz, x, u->ch[0]);
    u->pushup();
}
```

ï¼ˆä¸è¦å¿˜è®° pushdown/upï¼‰

åˆå¹¶å°±ç®€å•ä¸å°‘ï¼æˆ‘ä»¬å¾…åˆå¹¶çš„ä¸¤æ£µæ ‘å€¼åŸŸæ˜¯ä¸äº¤çš„ï¼Œä»¥ä¸‹å‡å®š $x$ æ ‘å†…çš„å€¼å‡å°äº $y$ æ ‘å†…çš„ï¼Œé‚£ä¹ˆä¸€å®šåªæœ‰ä¸¤ç§æƒ…å†µï¼š
1. å°† $x$ åˆå¹¶åˆ° $y$ çš„å·¦å­æ ‘ï¼›
2. å°† $y$ åˆå¹¶åˆ° $x$ çš„å³å­æ ‘ã€‚

é‚£ä¹ˆåˆ°åº•é€‰ç”¨é‚£ç§æƒ…å†µå‘¢ï¼Ÿæˆ‘ä»¬è€ƒè™‘ Treap è¿˜æœ‰ä¸€ä¸ªéšæœºæƒå€¼æ»¡è¶³ heap çš„æ€§è´¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ˆä»¥å°æ ¹å †ä¸ºä¾‹ï¼‰ï¼š
1. å¦‚æœç‚¹ $x$ çš„éšæœºæƒå€¼æ¯” $y$ çš„éšæœºæƒå€¼å°ï¼Œé‚£ä¹ˆå°† $y$ åˆå¹¶åˆ° $x$ çš„å³å­æ ‘ï¼›
2. å¦åˆ™ï¼Œå°† $x$ åˆå¹¶åˆ° $y$ çš„å·¦å­æ ‘ã€‚

```cpp
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    if (x->rndval < y->rndval) return x->ch[1] = merge(x->ch[1], y), x->pushup(), x;
    return y->ch[0] = merge(x, y->ch[0]), y->pushup(), y;
}
```

ç®€å•çš„ç»´æŠ¤åºåˆ—ä¾‹é¢˜ï¼š[æ´›è°· P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1](https://www.luogu.com.cn/problem/P3372)ã€‚

ä»£ç ï¼š
```cpp
#define int long long

const int N = 1e5;

int n, m;

mt19937 rnd((unsigned long long)(new char));

struct Node {
    int val, rndval, sum, atag, sz;
    Node *ch[2];
    void add(int x) { val += x, sum += sz * x, atag += x; }
    void pushup() { sum = ch[0]->sum + ch[1]->sum + val, sz = ch[0]->sz + ch[1]->sz + 1; }
    void pushdown() { if (atag) ch[0]->add(atag), ch[1]->add(atag), atag = 0; }
} mem[N + 10], *atot = mem, *rt, *null;

void Init() { null = atot, null->ch[0] = null->ch[1] = null, rt = null; }
Node *newNode(int val) { return atot++, atot->ch[0] = atot->ch[1] = null, atot->sum = atot->val = val, atot->sz = 1, atot->rndval = rnd(), atot; }

void splitsz(Node *u, int sz, Node *&x, Node *&y) {
    if (u == null) return x = y = null, void();
    u->pushdown();
    if (u->ch[0]->sz + 1 <= sz) x = u, splitsz(u->ch[1], sz - u->ch[0]->sz - 1, u->ch[1], y);
    else y = u, splitsz(u->ch[0], sz, x, u->ch[0]);
    u->pushup();
}
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    if (x->rndval < y->rndval) return x->ch[1] = merge(x->ch[1], y), x->pushup(), x;
    return y->ch[0] = merge(x, y->ch[0]), y->pushup(), y;
}

signed main() {
    Init(), fr(n, m);
    for (int i = 1; i <= n; i++) rt = merge(rt, newNode(fr()));
    for (int _ = 1, op, l, r, v; _ <= m; _++) {
        fr(op, l, r);
        Node *x, *y, *z;
        splitsz(rt, l - 1, x, y), splitsz(y, r - l + 1, y, z);
        if (op == 1) fr(v), y->add(v);
        else printf("%lld\n", y->sum);
        rt = merge(x, merge(y, z));
    }
    return 0;
}
```

## æ•°æ®ç»“æ„ä¼˜åŒ–å»ºå›¾
### å‰ç¼€å’Œä¼˜åŒ–å»ºå›¾
æ„Ÿè§‰æ²¡å•¥éœ€è¦ç‰¹åˆ«è¯´çš„ï¼Œå°±æ˜¯åˆ©ç”¨å‰ç¼€å’Œçš„æ€§è´¨ï¼ŒæŠŠå‰ç¼€ç¼©æˆä¸€ä¸ªç‚¹ç„¶åå»ºå›¾ï¼Œæ„Ÿæ€§ç†è§£ä¸€ä¸‹åœºä¸Šç°æ¨å°±æ˜¯äº†ã€‚

ä¾‹é¢˜ï¼š[æ´›è°· P6378 [PA2010] Riddle](https://www.luogu.com.cn/problem/P6378)ã€‚
### çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾
useful trickã€‚ç”¨äºä¸€äº›éœ€è¦ç‚¹å‘åŒºé—´è¿è¾¹ / åŒºé—´å‘åŒºé—´è¿è¾¹çš„é¢˜ç›®ã€‚

æ€ä¹ˆåšï¼Ÿå»ºä¸¤æ£µçº¿æ®µæ ‘ï¼Œä¸€æ£µæ ‘ä¸Šçˆ¶äº²å‘å„¿å­è¿è¾¹æƒä¸º $0$ çš„æœ‰å‘è¾¹ï¼ˆè®°ä¸º $T_1$ï¼‰ï¼Œä¸€æ£µæ ‘ä¸Šå„¿å­å‘çˆ¶äº²è¿è¾¹æƒä¸º $0$ çš„æœ‰å‘è¾¹ï¼ˆè®°ä¸º $T_2$ï¼‰ï¼Œä¸¤æ£µæ ‘ç›¸åŒä½ç½®çš„å¶å­èŠ‚ç‚¹ä¹‹é—´è¿è¾¹æƒä¸º $0$ çš„æ— å‘è¾¹ã€‚

- ç‚¹å‘ç‚¹è¿è¾¹ï¼š$T_1,T_2$ å¯¹åº”å¶å­èŠ‚ç‚¹ç›¸è¿ã€‚
- ç‚¹å‘åŒºé—´è¿è¾¹ï¼š$T_2$ çš„å¶å­å‘ $T_1$ çš„åŒºé—´è¿è¾¹ã€‚
- åŒºé—´å‘ç‚¹è¿è¾¹ï¼š$T_2$ çš„åŒºé—´å‘ $T_1$ çš„å¶å­è¿è¾¹ã€‚
- åŒºé—´å‘åŒºé—´è¿è¾¹ï¼šå»ºä¸€ä¸ªè™šç‚¹ï¼Œ$T_1,T_2$ çš„åŒºé—´å‘è™šç‚¹è¿è¾¹ã€‚

æ„Ÿè§‰è€ƒåœºä¸Šæ‰‹ç”»ä¸¤æ£µçº¿æ®µæ ‘å°±èƒ½ç°æ¨äº†å•Š ğŸ¤”

ä¾‹é¢˜ï¼š[CF786B Legacy](https://www.luogu.com.cn/problem/CF786B)ã€‚

## æ‰‹å†™ Bitset
```cpp
struct Bitset {
    unsigned long long A[782];
    Bitset operator|(Bitset b) const {
        Bitset c;
        for (int i = 0; i <= len; i++) c.A[i] = A[i] | b.A[i];
        return c;
    }
    Bitset operator^(Bitset b) const {
        Bitset c;
        for (int i = 0; i <= len; i++) c.A[i] = A[i] ^ b.A[i];
        return c;
    }
    void reset() {
        for (int i = 0; i <= len; i++) A[i] = 0;
    }
    void set(int x) { A[x >> 6] |= 1ull << (x & 63); }
    void flip(int x) { A[x >> 6] ^= 1ull << (x & 63); }
    int count() {
        int ret = 0;
        for (int i = 0; i <= len; i++) ret += dt[A[i] >> 48] + dt[(A[i] >> 32) & S] + dt[(A[i] >> 16) & S] + dt[A[i] & S];
        return ret;
    }
}
```