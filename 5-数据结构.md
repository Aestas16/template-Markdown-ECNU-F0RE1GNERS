# 数据结构
## 笛卡尔树
一个满足「中序遍历序列是原序列」的堆，放个图：
![](https://oiwiki.org/ds/images/cartesian-tree1.png)

怎么建笛卡尔树？单调栈即可，如果实在不会也可以写多个 $\log$ 的 ST 表。怎么用？由于树上一个节点表示了一个区间的最大/小值，具有良好的性质，比如可以分治做一些东西。

例题：[洛谷 P7244 章节划分](https://www.luogu.com.cn/problem/P7244)。
## 线段树
### 李超线段树
考场上手画一下图然后现推「优势线段」的维护就行。

感觉这东西优化 DP 比斜率优化好写多了，就是有的时候比斜率优化多个 $\log$。
### 线段树合并
一般用于快速合并两个数组的信息，多用于树上 DP 时加速转移。可以证明时间复杂度是 $\Theta(n \log n)$ 的。

```cpp
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    ... // 将 y 的信息合并到 x 上
    x->ch[0] = merge(x->ch[0], y->ch[0]), x->ch[1] = merge(x->ch[1], y->ch[1]), x->pushup();
    return x;
}
```
### 兔队线段树
[名字来源](https://www.luogu.com.cn/blog/PinkRabbit/Segment-Tree-and-Prefix-Maximums)。

useful trick。使用线段树维护前缀最大值的一个 trick。

浅举个例子：查询区间本质不同前缀最大值数量。我们对线段树上的一个节点 $[l,r]$ 维护两个信息：
1. 区间最大值 $\max$。
2. 仅考虑区间 $[l,r]$ 时，该区间的答案 $\text{ans}$。

然后我们考虑 pushup，会发现 $\text{ans}$ 好像不太好合并啊，我们可以直接继承左儿子的答案，但是要计算右子树的答案我们还得考虑左子树的最大值 🤔

于是我们定义一个函数 $\text{calc}(i,pre)$ 表示节点 $i$ 考虑了前面含有最大值 $pre$ 的答案（抄的粉兔博客代码）：

$\displaystyle \begin{array}{l} \textbf{def: } \mathrm{calc}(i, pre) \\ \qquad \textbf{if } (i \text{ is a leaf node}) \\ \qquad \qquad \textbf{return } {\color{green}{[\max[i] > pre]}} \\ \qquad \textbf{else} \\ \qquad \qquad \textbf{if } (\max[\mathrm{leftchild}[i]] > pre) \\ \qquad \qquad \qquad \textbf{return } {\color{blue}{\mathrm{calc}(\mathrm{leftchild}[i], pre)}} + {\color{red}{(\mathrm{ans}[i] - \mathrm{ans}[\mathrm{leftchild}[i]])}} \\ \qquad \qquad \textbf{else} \\ \qquad \qquad \qquad \textbf{return } {\color{blue}{0}} + {\color{red}{\mathrm{calc}(\mathrm{rightchild}[i], pre)}} \\ \qquad \qquad \textbf{endif.} \\ \qquad \textbf{endif.} \\ \textbf{enddef.} \end{array}$

绿色为叶子节点的贡献，蓝色为左子树贡献，红色为右子树贡献。

第一块红色那里不太好理解，但是聪明的大家一定能懂！就不解释了！

然后我们发现第一块红色那边要做减法，也就是说我们维护的信息要满足可减性？那好像有点拉啊，我们考虑修改 $\text{ans}$ 的定义：
- 仅考虑区间 $[l,r]$ 时，右儿子区间的答案 $\text{ans}$。
- 叶子节点的 $\text{ans}$ 无意义。

这下第一块红色那里就可以改成 $\text{ans}[i]$ 了！不需要可减性了，那么只剩下新定义 $\text{ans}$ 的 pushup 问题，我们显然有 $\mathrm{cnt}[i] = \mathrm{calc}(\mathrm{rightchild}[i], \max[\mathrm{leftchild}[i]])$。

问题圆满解决！时间复杂度 $\Theta(n \log^2 n)$。

例题：[洛谷 P4198 楼房重建](https://www.luogu.com.cn/problem/P4198)。就是上面说的这个题辣！

### 可持久化线段树
空间是 $\Theta(n \log m)$ 的。

```cpp
const int N = 2e5;

int n, m, a[N + 10], arr[N + 10];

struct Node {
    int sum;
    Node *ch[2];
    void pushup() { sum = ch[0]->sum + ch[1]->sum; }
} mem[N * 20 + 10], *atot = mem, *rt[N + 10];

void build(Node *&u, int l = 1, int r = arr[0]) {
    u = ++atot;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(u->ch[0], l, mid), build(u->ch[1], mid + 1, r);
}
void update(Node *&u, Node *v, int pos, int val, int l = 1, int r = arr[0]) {
    u = ++atot, u->ch[0] = v->ch[0], u->ch[1] = v->ch[1], u->sum = v->sum;
    if (l == r) return u->sum += val, void();
    int mid = (l + r) >> 1;
    (pos <= mid) ? update(u->ch[0], v->ch[0], pos, val, l, mid) : update(u->ch[1], v->ch[1], pos, val, mid + 1, r);
    u->pushup();
}
int qkth(Node *ql, Node *qr, int k, int l = 1, int r = arr[0]) {
    if (l == r) return arr[l];
    int mid = (l + r) >> 1, sz = qr->ch[0]->sum - ql->ch[0]->sum;
    return (k <= sz) ? qkth(ql->ch[0], qr->ch[0], k, l, mid) : qkth(ql->ch[1], qr->ch[1], k - sz, mid + 1, r);
}

signed main() {
    fr(n, m);
    for (int i = 1; i <= n; i++) fr(a[i]), arr[i] = a[i];
    sort(arr + 1, arr + 1 + n), arr[0] = unique(arr + 1, arr + 1 + n) - arr - 1, build(rt[0]);
    for (int i = 1; i <= n; i++) update(rt[i], rt[i - 1], lower_bound(arr + 1, arr + 1 + arr[0], a[i]) - arr, 1);
    for (int i = 1, l, r, k; i <= m; i++) fr(l, r, k), printf("%d\n", qkth(rt[l - 1], rt[r], k));
    return 0;
}
```

## 莫队
**注意移动指针的时候应当先扩大区间，再缩小区间。**很重要！！！不这么写的莫队是假的！！！
### 带修莫队
给普通莫队加一维时间，这个不是难点。难点是高维莫队的复杂度分析：

设块长为 $B$，每一维值域大小为 $n$，询问数为 $m$，则 $k$ 维莫队时间复杂度为 $\Theta\left(\dfrac{n^k}{B^{k-1}}+mB\right)$，由基本不等式得当 $B=\dfrac{n}{\sqrt[k]{m}}$ 时时间复杂度取最小值 $\Theta\left(n\sqrt[k]{m^{k-1}}\right)$。
### 括号序树上莫队
考场上把括号序画出来现推一下就会了吧：
- $(u,v)$ 存在祖先后辈关系，那么把两个点的左括号位置作为询问区间的两端点；
- 反之，把一个点的左括号另一个点的右括号位置作为询问区间的两端点，但是这样会漏掉 LCA，记得把 LCA 补上。

整完了。

## 可并堆
### 随机堆
将堆 $y$ 合并到堆 $x$ 上时，以 $0.5$ 的概率交换 $x$ 的左右儿子，然后将 $x$ 的左儿子与 $y$ 合并，可以证明这样子合并得到的堆树高是 $\log n$ 级别的。

记得找堆顶要另外记一个父亲然后用并查集维护。

代码：
```cpp
const int N = 1e5;

mt19937 rnd((unsigned long long)(new char));
int n, m, fa[N + 10], ch[N + 10][2];
bool vis[N + 10];
pair<int, int> val[N + 10];

int find(int u) {
    if (fa[u] == u) return u;
    return fa[u] = find(fa[u]);
}
int merge(int x, int y) {
    if (x == 0 || y == 0) return x | y;
    if (val[x] > val[y]) swap(x, y);
    if (rnd() & 1) swap(ch[x][0], ch[x][1]);
    return ch[x][0] = merge(ch[x][0], y), x;
}

struct OI {
    int RP, score;
} FJOI2022;

signed main() {
    FJOI2022.RP++, FJOI2022.score++;
    fr(n, m);
    for (int i = 1; i <= n; i++) fr(val[i].first), val[i].second = i, fa[i] = i;
    for (int i = 1, op, x, y; i <= m; i++) {
        fr(op, x);
        if (op == 1) {
            fr(y);
            if (vis[x] || vis[y]) continue;
            x = find(x), y = find(y);
            if (x != y) fa[x] = fa[y] = merge(x, y);
        } else {
            if (vis[x]) { puts("-1"); continue; }
            x = find(x), fa[ch[x][0]] = fa[ch[x][1]] = fa[x] = merge(ch[x][0], ch[x][1]), vis[x] = 1, ch[x][0] = ch[x][1] = 0, printf("%d\n", val[x].first);
        }
    }
    return 0;
}
```

然后这东西有点类似于线段树合并，可以在堆顶上打标记对整个堆操作。

例题：[洛谷 P3261 [JLOI2015]城池攻占](https://www.luogu.com.cn/problem/P3261)。

## 平衡树
## FHQ Treap
维护序列的时候按大小把树分裂开提出区间打标记，维护集合的时候还需要按权值分裂的操作。

分裂的时候先考虑左子树是否完全被包括，是的话则将左子树加入前半边树里，往右子树递归分裂；如果未被完全包括，将左子树加入后半边树里，往左子树分裂递归。
```cpp
void splitsz(Node *u, int sz, Node *&x, Node *&y) {
    if (u == null) return x = y = null, void();
    u->pushdown();
    if (u->ch[0]->sz + 1 <= sz) x = u, splitsz(u->ch[1], sz - u->ch[0]->sz - 1, u->ch[1], y);
    else y = u, splitsz(u->ch[0], sz, x, u->ch[0]);
    u->pushup();
}
```

（不要忘记 pushdown/up）

合并就简单不少！我们待合并的两棵树值域是不交的，以下假定 $x$ 树内的值均小于 $y$ 树内的，那么一定只有两种情况：
1. 将 $x$ 合并到 $y$ 的左子树；
2. 将 $y$ 合并到 $x$ 的右子树。

那么到底选用那种情况呢？我们考虑 Treap 还有一个随机权值满足 heap 的性质，也就是说（以小根堆为例）：
1. 如果点 $x$ 的随机权值比 $y$ 的随机权值小，那么将 $y$ 合并到 $x$ 的右子树；
2. 否则，将 $x$ 合并到 $y$ 的左子树。

```cpp
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    if (x->rndval < y->rndval) return x->ch[1] = merge(x->ch[1], y), x->pushup(), x;
    return y->ch[0] = merge(x, y->ch[0]), y->pushup(), y;
}
```

简单的维护序列例题：[洛谷 P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)。

代码：
```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

template <class T> void fr(T &a, bool f = 0, char ch = getchar()) {
    for (a = 0; ch < '0' || ch > '9'; ch = getchar()) (ch == '-') && (f = 1);
    for (; ch >= '0' && ch <= '9'; ch = getchar()) a = a * 10 + (ch - '0');
    f && (a = -a);
}
template <class T, class... Y> void fr(T &a, Y &...b) { fr(a), fr(b...); }
int fr() { int a; return fr(a), a; }

const int N = 1e5;

int n, m;

mt19937 rnd((unsigned long long)(new char));

struct Node {
    int val, rndval, sum, atag, sz;
    Node *ch[2];
    void add(int x) { val += x, sum += sz * x, atag += x; }
    void pushup() { sum = ch[0]->sum + ch[1]->sum + val, sz = ch[0]->sz + ch[1]->sz + 1; }
    void pushdown() { if (atag) ch[0]->add(atag), ch[1]->add(atag), atag = 0; }
} mem[N + 10], *atot = mem, *rt, *null;

void Init() { null = atot, null->ch[0] = null->ch[1] = null, rt = null; }
Node *newNode(int val) { return atot++, atot->ch[0] = atot->ch[1] = null, atot->sum = atot->val = val, atot->sz = 1, atot->rndval = rnd(), atot; }

void splitsz(Node *u, int sz, Node *&x, Node *&y) {
    if (u == null) return x = y = null, void();
    u->pushdown();
    if (u->ch[0]->sz + 1 <= sz) x = u, splitsz(u->ch[1], sz - u->ch[0]->sz - 1, u->ch[1], y);
    else y = u, splitsz(u->ch[0], sz, x, u->ch[0]);
    u->pushup();
}
Node *merge(Node *x, Node *y) {
    if (x == null || y == null) return (x == null) ? y : x;
    x->pushdown(), y->pushdown();
    if (x->rndval < y->rndval) return x->ch[1] = merge(x->ch[1], y), x->pushup(), x;
    return y->ch[0] = merge(x, y->ch[0]), y->pushup(), y;
}

struct OI {
    int RP, score;
} NOIP2022;

signed main() {
    NOIP2022.RP++, NOIP2022.score++;
    Init(), fr(n, m);
    for (int i = 1; i <= n; i++) rt = merge(rt, newNode(fr()));
    for (int _ = 1, op, l, r, v; _ <= m; _++) {
        fr(op, l, r);
        Node *x, *y, *z;
        splitsz(rt, l - 1, x, y), splitsz(y, r - l + 1, y, z);
        if (op == 1) fr(v), y->add(v);
        else printf("%lld\n", y->sum);
        rt = merge(x, merge(y, z));
    }
    return 0;
}
```

## 数据结构优化建图
### 前缀和优化建图
感觉没啥需要特别说的，就是利用前缀和的性质，把前缀缩成一个点然后建图，感性理解一下场上现推就是了。

例题：[洛谷 P6378 [PA2010] Riddle](https://www.luogu.com.cn/problem/P6378)。
### 线段树优化建图
useful trick。用于一些需要点向区间连边 / 区间向区间连边的题目。

怎么做？建两棵线段树，一棵树上父亲向儿子连边权为 $0$ 的有向边（记为 $T_1$），一棵树上儿子向父亲连边权为 $0$ 的有向边（记为 $T_2$），两棵树相同位置的叶子节点之间连边权为 $0$ 的无向边。

- 点向点连边：$T_1,T_2$ 对应叶子节点相连。
- 点向区间连边：$T_2$ 的叶子向 $T_1$ 的区间连边。
- 区间向点连边：$T_2$ 的区间向 $T_1$ 的叶子连边。
- 区间向区间连边：建一个虚点，$T_1,T_2$ 的区间向虚点连边。

感觉考场上手画两棵线段树就能现推了啊 🤔

例题：[CF786B Legacy](https://www.luogu.com.cn/problem/CF786B)。